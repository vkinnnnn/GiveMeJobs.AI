"""
Automated vulnerability scanning tests.
"""

import pytest
import subprocess
import json
import os
from pathlib import Path
from typing import Dict, List, Any
import tempfile


@pytest.mark.security
class TestAutomatedSecurityScanning:
    """Automated security scanning tests."""
    
    def test_bandit_security_scan(self):
        """Run Bandit security scan on codebase."""
        # Run Bandit scan
        result = subprocess.run([
            "bandit", 
            "-r", "app/",
            "-f", "json",
            "-o", "bandit_report.json",
            "--skip", "B101,B601"  # Skip assert and shell usage in tests
        ], capture_output=True, text=True, cwd="packages/python-services")
        
        # Check if report was generated
        report_path = Path("packages/python-services/bandit_report.json")
        if report_path.exists():
            with open(report_path, 'r') as f:
                report = json.load(f)
            
            # Check for high severity issues
            high_severity_issues = [
                issue for issue in report.get("results", [])
                if issue.get("issue_severity") == "HIGH"
            ]
            
            # Fail if high severity issues found
            if high_severity_issues:
                issues_summary = "\n".join([
                    f"- {issue['test_name']}: {issue['issue_text']} "
                    f"({issue['filename']}:{issue['line_number']})"
                    for issue in high_severity_issues
                ])
                pytest.fail(f"High severity security issues found:\n{issues_summary}")
            
            # Log medium severity issues as warnings
            medium_severity_issues = [
                issue for issue in report.get("results", [])
                if issue.get("issue_severity") == "MEDIUM"
            ]
            
            if medium_severity_issues:
                print(f"\nWarning: {len(medium_severity_issues)} medium severity issues found")
                for issue in medium_severity_issues[:5]:  # Show first 5
                    print(f"  - {issue['test_name']}: {issue['issue_text']}")
    
    def test_safety_dependency_scan(self):
        """Run Safety scan for vulnerable dependencies."""
        # Run Safety scan
        result = subprocess.run([
            "safety", "check", 
            "--json",
            "--output", "safety_report.json"
        ], capture_output=True, text=True, cwd="packages/python-services")
        
        # Check if vulnerabilities were found
        if result.returncode != 0:
            # Parse safety output
            try:
                vulnerabilities = json.loads(result.stdout)
                if vulnerabilities:
                    vuln_summary = "\n".join([
                        f"- {vuln['package']}: {vuln['vulnerability']}"
                        for vuln in vulnerabilities
                    ])
                    pytest.fail(f"Vulnerable dependencies found:\n{vuln_summary}")
            except json.JSONDecodeError:
                # Safety might output text format
                if "vulnerabilities found" in result.stdout.lower():
                    pytest.fail(f"Vulnerable dependencies found:\n{result.stdout}")
    
    def test_semgrep_security_scan(self):
        """Run Semgrep security scan."""
        # Run Semgrep scan with security rules
        result = subprocess.run([
            "semgrep",
            "--config=auto",
            "--json",
            "--output=semgrep_report.json",
            "app/"
        ], capture_output=True, text=True, cwd="packages/python-services")
        
        # Check if report was generated
        report_path = Path("packages/python-services/semgrep_report.json")
        if report_path.exists():
            with open(report_path, 'r') as f:
                report = json.load(f)
            
            # Check for security findings
            security_findings = [
                finding for finding in report.get("results", [])
                if "security" in finding.get("extra", {}).get("metadata", {}).get("category", "").lower()
            ]
            
            # Filter out low-confidence findings
            high_confidence_findings = [
                finding for finding in security_findings
                if finding.get("extra", {}).get("metadata", {}).get("confidence", "").upper() in ["HIGH", "MEDIUM"]
            ]
            
            if high_confidence_findings:
                findings_summary = "\n".join([
                    f"- {finding['check_id']}: {finding['message']} "
                    f"({finding['path']}:{finding['start']['line']})"
                    for finding in high_confidence_findings[:10]  # Show first 10
                ])
                pytest.fail(f"Security findings detected:\n{findings_summary}")


@pytest.mark.security
class TestPenetrationTesting:
    """Penetration testing scenarios."""
    
    def test_sql_injection_penetration(self):
        """Penetration test for SQL injection vulnerabilities."""
        import httpx
        import asyncio
        
        async def test_sql_injection():
            async with httpx.AsyncClient() as client:
                # SQL injection test payloads
                payloads = [
                    "' OR 1=1 --",
                    "'; DROP TABLE users; --",
                    "' UNION SELECT username, password FROM users --",
                    "' AND (SELECT COUNT(*) FROM users) > 0 --",
                    "admin'/*",
                    "' OR 'x'='x",
                    "1' AND 1=1 --",
                    "1' AND 1=2 --"
                ]
                
                vulnerable_endpoints = []
                
                for payload in payloads:
                    # Test search endpoint
                    try:
                        response = await client.get(
                            f"http://localhost:8000/api/v1/jobs/search?q={payload}",
                            timeout=5.0
                        )
                        
                        # Check for SQL error messages
                        error_indicators = [
                            "sql", "mysql", "postgresql", "sqlite", "oracle",
                            "syntax error", "column", "table", "database"
                        ]
                        
                        response_text = response.text.lower()
                        if any(indicator in response_text for indicator in error_indicators):
                            vulnerable_endpoints.append(f"search endpoint with payload: {payload}")
                        
                        # Check for unusual response times (blind SQL injection)
                        if response.elapsed.total_seconds() > 5:
                            vulnerable_endpoints.append(f"search endpoint (timing attack) with payload: {payload}")
                            
                    except Exception as e:
                        # Timeouts might indicate successful injection
                        if "timeout" in str(e).lower():
                            vulnerable_endpoints.append(f"search endpoint (timeout) with payload: {payload}")
                
                if vulnerable_endpoints:
                    pytest.fail(f"Potential SQL injection vulnerabilities:\n" + 
                               "\n".join(f"- {vuln}" for vuln in vulnerable_endpoints))
        
        asyncio.run(test_sql_injection())
    
    def test_xss_penetration(self):
        """Penetration test for XSS vulnerabilities."""
        import httpx
        import asyncio
        
        async def test_xss():
            async with httpx.AsyncClient() as client:
                # XSS test payloads
                payloads = [
                    "<script>alert('XSS')</script>",
                    "<img src=x onerror=alert('XSS')>",
                    "javascript:alert('XSS')",
                    "<svg onload=alert('XSS')>",
                    "';alert('XSS');//",
                    "<iframe src=javascript:alert('XSS')></iframe>",
                    "<body onload=alert('XSS')>",
                    "<input onfocus=alert('XSS') autofocus>"
                ]
                
                vulnerable_endpoints = []
                
                for payload in payloads:
                    try:
                        # Test profile update endpoint
                        profile_data = {
                            "professional_headline": payload,
                            "summary": f"Test summary {payload}"
                        }
                        
                        response = await client.put(
                            "http://localhost:8000/api/v1/users/me",
                            json=profile_data,
                            headers={"Authorization": "Bearer test-token"},
                            timeout=5.0
                        )
                        
                        if response.status_code == 200:
                            # Check if payload is reflected without sanitization
                            response_text = response.text
                            if payload in response_text:
                                vulnerable_endpoints.append(f"profile update with payload: {payload}")
                        
                        # Test search endpoint
                        response = await client.get(
                            f"http://localhost:8000/api/v1/jobs/search?q={payload}",
                            timeout=5.0
                        )
                        
                        if payload in response.text:
                            vulnerable_endpoints.append(f"search endpoint with payload: {payload}")
                            
                    except Exception:
                        pass  # Ignore errors for penetration testing
                
                if vulnerable_endpoints:
                    pytest.fail(f"Potential XSS vulnerabilities:\n" + 
                               "\n".join(f"- {vuln}" for vuln in vulnerable_endpoints))
        
        asyncio.run(test_xss())
    
    def test_authentication_bypass_penetration(self):
        """Penetration test for authentication bypass."""
        import httpx
        import asyncio
        
        async def test_auth_bypass():
            async with httpx.AsyncClient() as client:
                # Authentication bypass test cases
                bypass_attempts = []
                
                # Test JWT manipulation
                jwt_payloads = [
                    "Bearer null",
                    "Bearer undefined",
                    "Bearer {}",
                    "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyX2lkIjoiYWRtaW4ifQ.",  # None algorithm
                    "Bearer admin",
                    "Bearer guest",
                    "Bearer anonymous"
                ]
                
                protected_endpoint = "/api/v1/users/me"
                
                for payload in jwt_payloads:
                    try:
                        response = await client.get(
                            f"http://localhost:8000{protected_endpoint}",
                            headers={"Authorization": payload},
                            timeout=5.0
                        )
                        
                        # Should not allow access with invalid tokens
                        if response.status_code == 200:
                            bypass_attempts.append(f"Authentication bypass with: {payload}")
                            
                    except Exception:
                        pass
                
                # Test parameter pollution
                pollution_tests = [
                    {"user_id": ["user1", "admin"]},
                    {"role": ["user", "admin"]},
                    {"permissions": ["read", "admin"]}
                ]
                
                for params in pollution_tests:
                    try:
                        response = await client.get(
                            f"http://localhost:8000{protected_endpoint}",
                            params=params,
                            timeout=5.0
                        )
                        
                        if response.status_code == 200:
                            bypass_attempts.append(f"Parameter pollution bypass: {params}")
                            
                    except Exception:
                        pass
                
                if bypass_attempts:
                    pytest.fail(f"Potential authentication bypass vulnerabilities:\n" + 
                               "\n".join(f"- {attempt}" for attempt in bypass_attempts))
        
        asyncio.run(test_auth_bypass())
    
    def test_directory_traversal_penetration(self):
        """Penetration test for directory traversal vulnerabilities."""
        import httpx
        import asyncio
        
        async def test_directory_traversal():
            async with httpx.AsyncClient() as client:
                # Directory traversal payloads
                payloads = [
                    "../../../etc/passwd",
                    "..\\..\\..\\windows\\system32\\config\\sam",
                    "....//....//....//etc/passwd",
                    "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                    "..%252f..%252f..%252fetc%252fpasswd",
                    "..%c0%af..%c0%af..%c0%afetc%c0%afpasswd"
                ]
                
                vulnerable_endpoints = []
                
                for payload in payloads:
                    try:
                        # Test file access endpoints
                        file_endpoints = [
                            f"/api/v1/files/{payload}",
                            f"/api/v1/documents/{payload}",
                            f"/api/v1/uploads/{payload}"
                        ]
                        
                        for endpoint in file_endpoints:
                            response = await client.get(
                                f"http://localhost:8000{endpoint}",
                                headers={"Authorization": "Bearer test-token"},
                                timeout=5.0
                            )
                            
                            # Check for system file content
                            system_indicators = [
                                "root:", "bin/bash", "daemon:", "sys:",  # /etc/passwd
                                "administrator", "guest",  # Windows users
                                "[boot loader]", "[operating systems]"  # Windows boot
                            ]
                            
                            response_text = response.text.lower()
                            if any(indicator in response_text for indicator in system_indicators):
                                vulnerable_endpoints.append(f"{endpoint} with payload: {payload}")
                                
                    except Exception:
                        pass
                
                if vulnerable_endpoints:
                    pytest.fail(f"Potential directory traversal vulnerabilities:\n" + 
                               "\n".join(f"- {vuln}" for vuln in vulnerable_endpoints))
        
        asyncio.run(test_directory_traversal())


@pytest.mark.security
class TestSecurityMisconfiguration:
    """Test for security misconfigurations."""
    
    def test_default_credentials(self):
        """Test for default credentials."""
        import httpx
        import asyncio
        
        async def test_defaults():
            async with httpx.AsyncClient() as client:
                # Common default credentials
                default_creds = [
                    ("admin", "admin"),
                    ("admin", "password"),
                    ("admin", "123456"),
                    ("root", "root"),
                    ("test", "test"),
                    ("guest", "guest"),
                    ("user", "user")
                ]
                
                successful_logins = []
                
                for username, password in default_creds:
                    try:
                        login_data = {
                            "email": f"{username}@example.com",
                            "password": password
                        }
                        
                        response = await client.post(
                            "http://localhost:8000/api/v1/auth/login",
                            json=login_data,
                            timeout=5.0
                        )
                        
                        if response.status_code == 200:
                            successful_logins.append(f"{username}:{password}")
                            
                    except Exception:
                        pass
                
                if successful_logins:
                    pytest.fail(f"Default credentials found:\n" + 
                               "\n".join(f"- {cred}" for cred in successful_logins))
        
        asyncio.run(test_defaults())
    
    def test_debug_endpoints_exposure(self):
        """Test for exposed debug endpoints."""
        import httpx
        import asyncio
        
        async def test_debug_exposure():
            async with httpx.AsyncClient() as client:
                # Common debug endpoints
                debug_endpoints = [
                    "/debug",
                    "/api/debug",
                    "/admin",
                    "/test",
                    "/dev",
                    "/api/v1/debug",
                    "/api/v1/admin/debug",
                    "/health/debug",
                    "/metrics/debug",
                    "/status/debug"
                ]
                
                exposed_endpoints = []
                
                for endpoint in debug_endpoints:
                    try:
                        response = await client.get(
                            f"http://localhost:8000{endpoint}",
                            timeout=5.0
                        )
                        
                        # Check if endpoint returns sensitive information
                        if response.status_code == 200:
                            response_text = response.text.lower()
                            sensitive_indicators = [
                                "debug", "stack trace", "error", "exception",
                                "database", "config", "environment", "secret"
                            ]
                            
                            if any(indicator in response_text for indicator in sensitive_indicators):
                                exposed_endpoints.append(endpoint)
                                
                    except Exception:
                        pass
                
                if exposed_endpoints:
                    pytest.fail(f"Debug endpoints exposed:\n" + 
                               "\n".join(f"- {endpoint}" for endpoint in exposed_endpoints))
        
        asyncio.run(test_debug_exposure())
    
    def test_information_leakage(self):
        """Test for information leakage in error messages."""
        import httpx
        import asyncio
        
        async def test_info_leakage():
            async with httpx.AsyncClient() as client:
                # Test various error conditions
                error_tests = [
                    ("/api/v1/users/999999", "GET"),  # Non-existent user
                    ("/api/v1/jobs/invalid-id", "GET"),  # Invalid job ID
                    ("/api/v1/auth/login", "POST"),  # Invalid login data
                ]
                
                information_leaks = []
                
                for endpoint, method in error_tests:
                    try:
                        if method == "GET":
                            response = await client.get(f"http://localhost:8000{endpoint}")
                        else:
                            response = await client.post(
                                f"http://localhost:8000{endpoint}",
                                json={"invalid": "data"}
                            )
                        
                        # Check for information leakage in error responses
                        response_text = response.text.lower()
                        leak_indicators = [
                            "database error", "sql error", "connection failed",
                            "internal server error", "stack trace", "traceback",
                            "file not found", "permission denied", "access denied"
                        ]
                        
                        for indicator in leak_indicators:
                            if indicator in response_text:
                                information_leaks.append(f"{endpoint}: {indicator}")
                                break
                                
                    except Exception:
                        pass
                
                # Don't fail for information leakage, just warn
                if information_leaks:
                    print(f"\nWarning: Potential information leakage detected:")
                    for leak in information_leaks:
                        print(f"  - {leak}")


@pytest.mark.security
class TestSecurityCompliance:
    """Test security compliance requirements."""
    
    def test_owasp_top_10_compliance(self):
        """Test OWASP Top 10 compliance."""
        compliance_issues = []
        
        # A01: Broken Access Control - tested in other methods
        # A02: Cryptographic Failures - test encryption
        try:
            from app.core.encryption import encrypt_sensitive_data
            test_data = "sensitive_information"
            encrypted = encrypt_sensitive_data(test_data)
            if encrypted == test_data:
                compliance_issues.append("A02: Cryptographic Failures - No encryption implemented")
        except ImportError:
            compliance_issues.append("A02: Cryptographic Failures - Encryption module not found")
        
        # A03: Injection - tested in penetration tests
        # A04: Insecure Design - architectural review needed
        # A05: Security Misconfiguration - tested in other methods
        # A06: Vulnerable Components - tested with safety scan
        # A07: Authentication Failures - tested in auth tests
        # A08: Software Integrity Failures - dependency verification
        # A09: Logging Failures - test logging security
        # A10: Server-Side Request Forgery - test SSRF protection
        
        if compliance_issues:
            print(f"\nOWASP Top 10 compliance issues found:")
            for issue in compliance_issues:
                print(f"  - {issue}")
    
    def test_gdpr_compliance(self):
        """Test GDPR compliance requirements."""
        gdpr_issues = []
        
        # Test data minimization
        # Test right to be forgotten
        # Test data portability
        # Test consent management
        
        # This is a placeholder - actual GDPR testing would require
        # more comprehensive checks based on specific requirements
        
        if gdpr_issues:
            print(f"\nGDPR compliance issues found:")
            for issue in gdpr_issues:
                print(f"  - {issue}")


def pytest_configure(config):
    """Configure pytest for security tests."""
    config.addinivalue_line(
        "markers", "security: marks tests as security tests"
    )


def pytest_collection_modifyitems(config, items):
    """Modify test collection for security tests."""
    for item in items:
        if "security" in item.keywords:
            # Add security marker
            item.add_marker(pytest.mark.security)
            
            # Set longer timeout for security tests
            if hasattr(item, 'timeout'):
                item.timeout = 30  # 30 seconds timeout for security tests